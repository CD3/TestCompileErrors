# TestCompileErrors

Sometimes you need to check that a snippet of code will not compile. For example, if you use [SFINAE](https://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error#:~:text=Substitution%20failure%20is%20not%20an%20error%20(SFINAE)%20refers%20to%20a,to%20describe%20related%20programming%20techniques.) to remove a method overload
so that the user cannot accidentally use your class incorrectly.

TestCompileErrors lets you put snippets of code that should not compile directly into your unit tests.
```cpp
// unittest.cpp
#define CATCH_CONFIG_MAIN
#include <catch.hpp>

#include<vector>

TEST_CASE("std::vector has a .size() method")
{
  std::vector<int> v;
  v.push_back(1);
  v.push_back(2);
  CHECK(v.size() == 2);
  CHECK_COMPILE_FAILS(
  v.length();
  )
}
```
To test that `v.length()` will not compile, simply download and include `TestCompileErrors.cmake` in your `CMakeLists.txt`
and run `cmake --build . --target test` in your build directory.
```cmake
# CMakeLists.txt
cmake_minimum_required(VERSION 3.13)

project(Test)

enable_testing()
include("TestCompileErrors.cmake")
add_executable(unittest unittest.cpp)
target_include_directories(unittest PUBLIC ${CMAKE_CURRENT_SOURCE_DIR})
```

```bash
$ mkdir build
$ cd build
$ cmake ..
-- The C compiler identification is GNU 9.3.0
-- The CXX compiler identification is GNU 9.3.0
-- Check for working C compiler: /usr/bin/cc
-- Check for working C compiler: /usr/bin/cc -- works
-- Detecting C compiler ABI info
-- Detecting C compiler ABI info - done
-- Detecting C compile features
-- Detecting C compile features - done
-- Check for working CXX compiler: /usr/bin/c++
-- Check for working CXX compiler: /usr/bin/c++ -- works
-- Detecting CXX compiler ABI info
-- Detecting CXX compiler ABI info - done
-- Detecting CXX compile features
-- Detecting CXX compile features - done
-- Found Python3: /home/user/.pyenv/shims/python3.8 (found version "3.8.2") found components: Interpreter
-- Configuring done
-- Generating done
-- Build files have been written to: /home/user/TestCompileErrors/testing/catch2/build
$ cmake --build . --target test
[0/1] Re-running CMake...
-- Configuring done
-- Generating done
-- Build files have been written to: /home/user/TestCompileErrors/testing/catch2/build
[0/1] Running tests...
Test project /home/user/TestCompileErrors/testing/catch2/build
    Start 1: compile_failures
1/1 Test #1: compile_failures .................   Passed   12.81 sec

100% tests passed, 0 tests failed out of 1

Total Test time (real) =  12.81 sec
```

If you want to check that the compiler is failing for the right reason, you can run the `TestCompileErrors.py`
script directly wit the `--verbose` option
```bash
$ python3 ./TestCompileErrors.py --verbose
File: /home/cclark/Code/sync/projects/TestCompileErrors/testing/catch2/build/_TestCompile.tmp/unittest.0.cpp
Snippet: None
====
None
====
Compiler Output:
====

====
File: /home/cclark/Code/sync/projects/TestCompileErrors/testing/catch2/build/_TestCompile.tmp/unittest.1.cpp
Snippet:
  v.length();

====

  v.length();

====
Compiler Output:
====
/home/cclark/Code/sync/projects/TestCompileErrors/testing/catch2/build/_TestCompile.tmp/unittest.1.cpp: In function ‘void ____C_A_T_C_H____T_E_S_T____0()’:
/home/cclark/Code/sync/projects/TestCompileErrors/testing/catch2/build/_TestCompile.tmp/unittest.1.cpp:13:5: error: ‘class std::vector<int>’ has no member named ‘length’
   13 |   v.length();
      |     ^~~~~~

====
```

You can also build and run your unit tests.
```bash
$ cmake --build .
[2/2] Linking CXX executable unittest
$ ./unittest
===============================================================================
All tests passed (1 assertion in 1 test case)
```

## How it works

TestCompileErrors works by reading the JSON compile database and looking for files that contain
`CHECK_COMPILE_FAILS(...)` macros. When a file with the macro is found, TestCompileErrors will make a copy
of the file with all of the macros removed. It will then make a copy for macro with the snippet inserted
and all other macros removed. TestCompileErrors then uses the command found in the compile database to
compile each of these copies. It checks that the first copy, with no snippets, compiles without failure
and that the remaining files fail to compile. This is all done with a script named `TestCompileErrors.py`
that is generated by cmake and written to the build directory.

To allow snippets of code to be written directly into your unit tests, TestCompileErrors creates a
header named `TestCompileErrors-RemoveFailSnippets.h` that defines the `CHECK_COMPILE_FAILS(...)`
macro as a noop.
```bash
$ cat TestCompileErrors-RemoveFailSnippets.h

#define CHECK_COMPILE_FAILS(...)
```
This file is then force included to remove all snippets that will fail.

When you include `TestCompileErrors.cmake` into your `CMakeLists.txt` it will:

1. Search for a Python3 interpreter with `find_package(Python3 REQUIRED)`.
1. set `CMAKE_EXPORT_COMPILE_COMMANDS` to `ON`.
1. Generate the `TestCompileErrors.py` script.
1. Add a test for compile failures with `add_test( NAME compile_failures COMMAND ${Python3_EXECUTABLE} ./TestCompileErrors.py)`.
1. Generate the `TestCompileErrors-RemoveFailSnippets.h` header.
1. Force include `TestCompileErrors-RemoveFailSnippets.h` in all sources by adding a global compile option
   (using `/FI` for MSVC and `-include` otherwise).



